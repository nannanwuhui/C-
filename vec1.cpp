#include <iostream>
//每一个容器都有自己的头文件,头文件的文件名和容器的名字是一样的
//一般来讲，以后所有使用数组的地方都可以用向量来代替了，向量的功能只会比数组强，不会比数组弱
#include <vector>
/**
 * 所有的STL容器的名字空间也是std
 * c++的标准库只有一个名字空间,都是std
 * 有了std,io流可以用了,STL的库你也能用
 */
using namespace std;
void show(const vector<int>& vi){
    //所有的STL容器都有size()函数，都是用size()获取元素的个数
    size_t size = vi.size();
    cout << "大小：" << vi.size() << endl;
    for(size_t i = 0;i < size;++i)
        cout << vi[i] << ' ';
    cout << endl;
}
int main(){
    vector<int> v1;//空向量，不占内存
    show(v1);
    vector<int> v2(5);
    v2[0]=10;
    v2[2]=30;
    v2[4]=50;
    show(v2);
    vector<int> v3(5,1000);
    show(v3);
    int a[] = {100,200,300,400,500};
    vector<int> v4(a,a+5);
    show(v4);
    vector<int> v5 = v4;//拷贝构造（STL支持深拷贝）
    v5.pop_back();
    v4[4]++;
    show(v5);
    show(v4);
    v4.push_back(1234);
    show(v4);
    cout << v4.front() << endl;
    cout << v4.back() << endl;
    /**
      *list<int>内部的内存是不连续的，vector<int>内部的内存是连续的，但是这里
      * 我们打印的方法完全一样，这就是迭代器给我们带来的方便，但是list和vector内部
      * 的迭代器的实现肯定是不一样的
      */
    for(vector<int>::iterator it = v4.begin();it != v4.end();++it)
        cout << *it << ' ';
    cout << endl;
    vector<int>::iterator it = v4.begin();
    *it = 1;//v4[0] = 1;
    /**
      *　迭代器里封装了一个int*,做完地址和一个整数相加以后，返回
      * 相加以后的地址，然后对返回后的地址做解引用，就可以操作容器中的
      * 元素了
      */
    *(it + 1) = 2;//v4[1] = 2;
    *(it + 2) = 3;//v4[2] = 3;
    show(v4);
    //it指向被删除元素的下一个元素
    it = v4.erase(it + 3);
    show(v4);
    //it指向插入的元素,在迭代器it所指向元素的前面插入
    it = v4.insert(it,4);
    show(v4);
    //反向迭代器，当你面向首端的时候，是反向迭代器，
    //当你面向尾端的时候，是正向迭代器
    for(vector<int>::reverse_iterator it = v4.rbegin();it != v4.rend();++it)
        cout << *it << ' ';
    cout << endl;
    //一个普通的迭代器可以被隐式的转换成常迭代器
    vector<int>::const_iterator cit = it;
    cout << *it << endl;//4
//    ++*cit;//常迭代器相当于常指针，指向的目标不可被修改
    /**
      * 如果一个迭代器不能移动，也就是不能迭代，那迭代器就没有任何价值
      * 因为迭代器就是为了迭代而存在的
      */
    cit += 2;//常迭代器本身可以被修改
    cout << *cit << endl;
    vector<int> v6(1,100);
    it = v6.begin();
    cout << *it << endl;//100
    /**
      * 向向量里放东西的时候有可能会使其内部结构发生变化，不是简单的在后面加上一个元素
      * 就可以了，它的内存布局是要调整的,比如连续的内存不够了，它就需要另外开一块连续的内存，
      * 然后把现在内存里的东西拷贝过去，100这个元素的地址肯定变了，但是it还存放着100以前的地址，
      * 所以*it肯定就不是100了。it就会变成野指针。
      * it被初始化以后就和容器没有关系了，容器的内部结构发生变化，it里存放的地址不会同步
      * 如果只是遍历一下，对以前的元素做个++,--,容器内部的结构没有发生变化，那it肯定还是有效
      * 的,可以直接用，但是如果做了，push_back(),pop_back(),insert(),erase()这些可能使容器的结构发生
      * 变化的操作以后，迭代器应该重新初始化以后再使用才安全，当然也可能连续的内存够用，
      * it没有失效，勉强能用，但是没人能够保证it一定能用。
      */
    v6.push_back(200);
    it = v6.begin();
    cout << *it << endl;//0,重新初始化以后100
    return 0;
}
#if 0
4、vector是一个模板
实例化：
1）vector<元素类型> 向量对象；
定义空向量（既没有元素也没有内存，随着你加入数据，自动地增长内存）：vector<int> vi;
2）vector<元素类型> 向量对象(初始大小)；通过指定初始大小来预分配空间
1}基本类型元素，用适当类型的零初始化
vector<int> vi(10);
2}类类型的元素，用缺省构造函数初始化（前提是这个类必须得有缺省构造，如果你定义了构造函数并且是有参的，那这个类就没有缺省构造了。如果再定义一个无参构造，则这个无参构造就是缺省的构造函数，定义类的时候如果不传参数，就是使用缺省构造，然后用默认值去初始化类中的成员变量），如果没有缺省构造的话，就会有编译错误，解决方法：提供一个无参构造即可。无参构造就会成为缺省构造。
vector<Student> vs(10);
3}vector<元素类型> 向量对象（初始大小，元素初值）；
根据指定的元素初值，初始化向量元素
vector<double> vd(10,1.23);
4}vector<元素类型> 向量对象（起始迭代器，终止迭代器）；
用另一个容器起始迭代器和终止迭代器之间的元素，初始化向量中的元素
int a[5] = {1,2,3,4,5}；
vector<int> vi(&a[0],&a[5]);
终止迭代器是最后一个元素的下一个元素所对应的迭代器；
指针也是迭代器。两者的访问外观是一样的。都可以++,--,*,->，==，！=等
迭代器和指针之间的一个重要区别就是不存在值为NULL的迭代器，即不能用NULL或0初始化迭代器
迭代器（Iterator）：
1）迭代器是容器模板的公有内置类型
vector<int>::iterator it;
起始迭代器指向容器的第一个元素：
vector<int>::iterator it = vi.begin();
终止迭代器指向容器最后一个元素的下一个位置：
vector<int>::iterator it = vi.end();
通过迭代器遍历容器中的元素：
for(it = vn.begin();it!=vn.end();it++)
cout << *it << endl;
２）迭代器的指针操作：
*/->：访问目标元素本身或其成员
--/++：向前或向后移动一个位置
-/-=/+/+=：向前或向后移动若干位置（随机迭代器）内部必须连续
==/!=：是否指向相同或不同的目标元素
</>：是否更靠前或更靠后（随机迭代器）内存必须连续
拷贝构造/拷贝赋值：只复制迭代器本身，不复制目标元素
容器做深拷贝，迭代器做浅拷贝
迭代器和指针虽然本质不同，但是行为相同
内存连续的容器对应的迭代器叫随机迭代器，比如：向量，双端队列，
随机迭代器和和一个整数做加减运算
双向迭代器与随机迭代器（STL里面已经没有单向迭代器了，因为双向迭代器也能做单向迭代器的事）
双向迭代器：双向行进，递增前进，递减后退 　如果要实现泛型算法，用双向迭代器，因为这样会更加通用，因为它要求的少，要求越少就会越通用．

向量：
常用成员函数：
１）获取首／尾元素：
value_type& front();
const value_type& front()const;
value_type& back();
const value_type& back()const;
2）压入／弹出元素
//向量只有push_back和pop_back，因为向量的首端是被封死的。
void push_back(const value_type& val);
void pop_back();
３）插入／删除元素
//返回被插入元素的迭代器
iterator insert(iterator loc,const value_type& val);
//返回被删除元素的下一个元素的迭代器
iterator erase(iterator loc);
４）获得正／反向起／止迭代器
iterator begin();
const_iterator begin()const;
iterator end();
const_iterator end();
reverse_iterator rbegin();
const_reverse_iterator rbegin()const;
reverse_iterator rend();
const_reverse_iterator rend()const;
5）任何可能导致容器结构发生变化的函数被调用以后，先前获得的迭代器都可能因此失效，重新初始化以后再使用才是安全的
6）
1}获取大小，即元素个数
size_type size()const;
2)改变大小，可增可减，增构造，减析构
改变大小向量里存放的对象可以被构造和析构，对象本身在向量里所占用的内存不会被释放
也就是说向量所占用的内存空间只增不减，只有当向量离开自己的作用域（比如局部变量离开自己作用域）以后，向量的内存才会被释放。向量的析构函数会负责它所动态分配的资源，这
是可以保证的。但是如果你的向量是个全局变量，或者是单类模式里创建的对象（向量），
那么向量所占用的内存空间会随着进程的运行持续增长，不会有回缩。所以一般不在向量里面
放太大的对象。但是如果我的对象需要更多的内存怎么办呢？你可以自己动态分配，在构造的时候动态分配，在析构的时候就会被释放，像在resize(),erase(),pop都会调用析构函数，析构的时候就可以把动态分配的大块内存给释放了。
但是如果你在栈里开辟了一大块内存，在执行resize(),erase(),pop的时候是不会被释放的，只有当你定义的变量离开自己的作用域或者进程结束的时候才会被释放。
void resize(size_type num,const value_type& val = value_type());
3}清空向量，相当于resize(0);
void clear();对象都会调用析构函数，但是对象本身所占用的内存不被释放。
4}是否为空，空返回true,否则返回false
bool empty()const;实际上就是判断一下size(),size()==0就返回true,!=0就返回false
5｝获取容量，即最多能容纳多少个元素
大小是现在实际存储的元素的个数，容量是最多能容纳元素的个数。
size_type capacity()const;
６｝改变容量,只增不减，新增部分不做初始化，
void reserve(size_type size);
不管是向量的内存被动的增加还是主动调用reserve()函数改变容量，向量所占有的内存都是只增不减的，所以使用的时候要小心。
大小和容量
１、向量大小可增可减，改变向量大小的成员函数除resize()外，还有push_back(),pop_back(),insert()和erase()等
２、向量容器只增不减，改变向量容器的成员函数只有reserve()
３、向量大小的增加可能会导致其容量的增加，但向量容量的变化不会影响其大小。
４、通过resize()成员函数增加向量的大小，新增部分被初始化
５、通过reserve()成员函数增加向量的容量，新增部分不初始化
６、位于向量的容量范围内但不在其大小范围内的元素，也可以通过下标或迭代器访问，但其值未定义，也就是说内部不会将其作为有效元素来看待
７、由resize()和reserve()成员函数所引起的，向量大小和容量的变化，都发生在向量的尾部，
因为向量的首端是固定的。就像realloc只会在尾部增加一块内存，不会在首部增加
一般在向量里存放的对象所占用的内存空间都不大，对象内部可以动态分配更多的内存，这样在析构的时候就可以释放，我们可以控制对象内部内存的分配和释放，而对象本身所占内存是由容器来管理的，我们控制不了。而向量的内存只增不减，所以用向量存放的对象所占内存最好不要太大。
#endif
