#include <iostream>
using namespace std;
class A{
public:
    A(void){}
    A(const A& a){
        cout << "A的拷贝构造函数" << endl;
    }

};
A foo(A a){
    return a; 
}
A bar(void){
    A a;
    return a;
}
A& bar(A a){
    return a;
}
A& hum(A& a){
    return a;
}
int main(void){
    A a1;
    A a2(a1);
    A a3 = a2;
    A* pa = new A(a3);
    delete pa;
    //给函数传参的时候调用拷贝构造函数,这里调用了两次拷贝构造，因为返回的时候也会发生拷贝构造
    foo(a1);
    bar();//没有引发拷贝构造
    A a4;
    a4 = bar();//没有引发拷贝构造
    /**
     * 触发了两次拷贝构造，第一次是在传参的时候
     * 第二次是在返回的时候。但是返回的时候到底是否会有拷贝构造和编译器的优化有关
     * 这种情况下返回的是实参，返回的时候（会构造一个临时对象），会构建一个匿名对象(是a1的一个副本)
     * a1是有名字的，并且是实参，所以以后有可能对a1进行操作，但是不能影响foo()函数的返回值,
     * 是两个对象
     */
    foo(a1);//拷贝构造两次
    const A& ra = foo(a1);//拷贝构造两次
    /**
     * 没有拷贝构造，返回的不是形参，而是局部变量的值。返回以后不可能在main函数里操作bar函数里的
     * a,和编译器的优化有关,所以在堆栈弹出的时候，直接将bar函数栈里的a对象所占用的那一块内存直接拷贝到
     * main函数里，这样就可以避免一次拷贝构造，因为拷贝构造的开销比较大。
     */
    bar();//编译器优化，不会拷贝构造
    bar(a1);//返回局部变量的引用（警告），拷贝构造只调用一次
    /**
     *一次拷贝构造都没有，所以在定义函数的时候，尽量地在形参和返回值处使用引用，
     * 可以大大的减少拷贝构造,这样效率会比较高，并且使用拷贝构造的时候，如果缺省的拷贝
     * 构造不够用的话，还要提供自定义的拷贝构造函数，使用引用的话，就可以避免这样麻烦。
     * 并且由于不同的编译器可能编译器优化不一样,这样会导致在有的地方有的编译器
     * 需要拷贝构造函数，有的编译器不需要拷贝构造函数，使用不同的编译器有时候编译通过，
     * 有时候编译不通过，这样很麻烦，尽量的使用引用也可以避免这样的问题。
     */
    hum(a1);   
    return 0;
}
#if 0
4）拷贝构造的时机
A.用同类型的对象做初始化
B.函数调用传递对象型参数
C.函数返回对象（受编译优化的影响）
所以尽量的使用引用，这样可以提高效率，并且可以省掉很多麻烦。
#endif
